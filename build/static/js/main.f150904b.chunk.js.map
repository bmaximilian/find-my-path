{"version":3,"sources":["store/state/initialState.ts","store/actions/mapActions.ts","models/Cell.ts","algorithms/dijkstra.ts","components/Executor.tsx","components/Node.tsx","components/Grid.tsx","components/AlgorithmSelect.tsx","algorithms/maze/depth-first.ts","components/MazeExecutor.tsx","components/HeaderBar.tsx","util/generateGrid.ts","App.tsx","store/actions/configActions.ts","serviceWorker.ts","store/index.tsx","store/reducer/map.ts","store/reducer/config.ts","index.tsx"],"names":["initialState","map","grid","isDirty","isAnimating","config","algorithms","name","id","selectedAlgorithmIndex","replaceGrid","type","setGridDirty","setGridAnimating","CellTypes","updateNeighbors","cell","neighbors","row","col","isVisited","push","length","getUnvisitedNeighbors","forEach","neighbor","distance","prevCell","getShortestPathFromVisitedNodes","end","shortestPath","currentCell","setClassForCell","newClassName","element","document","getElementById","classesToRemove","classList","className","startsWith","remove","add","declareClassForCell","OBSTACLE","START","END","includes","isShortestPath","ALGORITHMS","gridClone","Infinity","undefined","visited","unvisited","reduce","flat","currentRow","start","list","index","findIndex","findFirstNodeOfType","Error","current","sort","a","b","shift","Executor","connect","state","isGridDirty","selectedAlgorithm","dispatch","animateSearch","result","i","setTimeout","animateShortestPath","Button","onClick","algorithm","searchResult","color","variant","disabled","Node","_","outerProps","props","classes","join","style","width","size","height","onMouseDown","e","onMouseUp","onMouseEnter","onMouseLeave","onMouseMove","isMouseDown","setMouseDown","newValue","Grid","memo","onSetCellAsObstacle","handleMouseEnter","rowId","key","prevProps","nextProps","AlgorithmSelect","React","useState","anchorEl","setAnchorEl","handleCloseMenu","aria-controls","aria-haspopup","event","currentTarget","Menu","keepMounted","open","Boolean","onClose","MenuItem","onSelect","handleSelectValue","Check","getRandomInt","min","max","Math","ceil","floor","random","excludedTypes","MazeExecutor","newGrid","examineDirections","setCellTypes","cell1","cell2","FREE","direction","depthFirst","useStyles","makeStyles","title","flexGrow","HeaderBar","onSelectAlgorithm","onClearGrid","AppBar","position","Toolbar","Typography","window","innerWidth","innerHeight","cellsPerRow","rowsCount","handleGenerateGrid","useCallback","Array","fill","rowIndex","isMiddleRow","_1","colIndex","useEffect","setSelectedAlgorithm","setCellAsObstacle","location","hostname","match","store","createStore","combineReducers","action","set","compose","Store","children","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.f150904b.chunk.js","sourcesContent":["import { Cell } from '../../models/Cell';\nimport { Algorithm } from '../../models/Algorithm';\n\nexport interface State {\n    map: {\n        grid: Cell[][];\n        isDirty: boolean;\n        isAnimating: boolean;\n    };\n    config: {\n        algorithms: Algorithm[];\n        selectedAlgorithmIndex: number;\n    };\n}\n\nexport const initialState: State = {\n    map: {\n        grid: [],\n        isDirty: false,\n        isAnimating: false,\n    },\n    config: {\n        algorithms: [\n            { name: 'Dijkstra', id: '1' },\n        ],\n        selectedAlgorithmIndex: 0,\n    },\n}\n","import { Action } from 'redux';\nimport { Cell } from '../../models/Cell';\n\nexport const SET_CELL_AS_OBSTACLE = 'GRID::SET_CELL_AS_OBSTACLE';\nexport const REPLACE_GRID = 'GRID::REPLACE_GRID';\nexport const SET_DIRTY = 'GRID::SET_DIRTY';\nexport const SET_ANIMATING = 'GRID::SET_ANIMATING';\nexport const SET_CELL_AS_SHORTEST_PATH = 'GRID::SET_CELL_AS_SHORTEST_PATH';\n\nexport function setCellAsObstacle(cell: Cell): Action<typeof SET_CELL_AS_OBSTACLE> & { cell: Cell } {\n    return {\n        type: SET_CELL_AS_OBSTACLE,\n        cell,\n    };\n}\n\nexport function replaceGrid(grid: Cell[][]): Action<typeof REPLACE_GRID> & { grid: Cell[][] } {\n    return {\n        type: REPLACE_GRID,\n        grid,\n    };\n}\n\nexport function setCellAsShortestPath(cell: Cell): Action<typeof SET_CELL_AS_SHORTEST_PATH> & { cell: Cell } {\n    return {\n        type: SET_CELL_AS_SHORTEST_PATH,\n        cell,\n    };\n}\n\nexport function setGridDirty(isDirty: boolean): Action<typeof SET_DIRTY> & { isDirty: boolean } {\n    return {\n        type: SET_DIRTY,\n        isDirty,\n    };\n}\n\nexport function setGridAnimating(isAnimating: boolean): Action<typeof SET_ANIMATING> & { isAnimating: boolean } {\n    return {\n        type: SET_ANIMATING,\n        isAnimating,\n    };\n}\n","export enum CellTypes {\n    OBSTACLE = 'obstacle',\n    START = 'start',\n    END = 'end',\n    FREE = 'free',\n}\n\nexport interface Cell {\n    size: number;\n    type: CellTypes;\n    isVisited: boolean;\n    isShortestPath?: boolean;\n    row: number;\n    col: number;\n}\n","import { Cell, CellTypes } from '../models/Cell';\n\ninterface Node extends Cell {\n    distance: number;\n    prevCell?: Node;\n}\n\nfunction sortByDistance(list: Node[]): Node[] {\n    return list.sort((a, b) => a.distance - b.distance);\n}\n\nfunction findFirstNodeOfType(type: CellTypes, list: Node[]): Node | null {\n    const index = list.findIndex(cell => cell.type === type);\n    return index === -1 ? null : list[index];\n}\n\nfunction getUnvisitedNeighbors(grid: Node[][], cell: Node): Node[] {\n    const neighbors = [];\n\n    // Check the upper cell\n    if (cell.row > 0 && !grid[cell.row - 1][cell.col].isVisited)\n        neighbors.push(grid[cell.row - 1][cell.col]);\n\n    // check the lower cell\n    if (cell.row < grid.length - 1 && !grid[cell.row + 1][cell.col].isVisited)\n        neighbors.push(grid[cell.row + 1][cell.col]);\n\n    // check the left cell\n    if (cell.col > 0 && !grid[cell.row][cell.col - 1].isVisited)\n        neighbors.push(grid[cell.row][cell.col - 1]);\n\n    // check the right cell\n    if (cell.col < grid[cell.row].length - 1 && !grid[cell.row][cell.col + 1].isVisited)\n        neighbors.push(grid[cell.row][cell.col + 1]);\n\n    return neighbors;\n}\n\nfunction updateNeighbors(grid: Node[][], cell: Node) {\n    const neighbors = getUnvisitedNeighbors(grid, cell);\n\n    neighbors.forEach((neighbor) => {\n        neighbor.distance = cell.distance + 1;\n        neighbor.prevCell = cell;\n    });\n}\n\nfunction getShortestPathFromVisitedNodes(end: Node): Node[] {\n    const shortestPath = [];\n    let currentCell = end.prevCell;\n\n    while(currentCell?.prevCell) {\n        shortestPath.push(currentCell);\n        currentCell = currentCell.prevCell;\n    }\n\n    return shortestPath;\n}\n\nexport interface Result {\n    shortestPath: Node[];\n    visited: Node[];\n}\n\nexport function dijkstra(grid: Cell[][]): Result {\n    const gridClone: Node[][] = grid.map(row => [...row.map(cell => ({\n        ...cell,\n        distance: Infinity,\n        prevCell: undefined,\n    }))]);\n\n    const visited = [];\n    const unvisited = gridClone.reduce((flat, currentRow) => [...flat, ...currentRow], []);\n    const start = findFirstNodeOfType(CellTypes.START, unvisited);\n\n    if (!start) {\n        throw new Error('Start point is missing');\n    }\n\n    start.distance = 0;\n\n    while(unvisited.length > unvisited.length - 1) {\n        const sortedNodes = sortByDistance(unvisited);\n        const current = sortedNodes.shift() as Node; // Undefined cant happen because while cond.\n\n        if (current?.type === CellTypes.OBSTACLE) continue;\n\n        current.isVisited = true;\n\n        visited.push(current);\n        if (current.type === CellTypes.END) break;\n        updateNeighbors(gridClone, current);\n    }\n\n    return {\n        visited: visited,\n        shortestPath: visited?.length > 0\n            ? getShortestPathFromVisitedNodes(visited[visited.length - 1])\n            : [],\n    };\n}\n","import { connect, DispatchProp } from 'react-redux';\nimport { Button } from '@material-ui/core';\nimport React from 'react';\nimport { initialState, State } from '../store/state/initialState';\nimport { setGridAnimating, setGridDirty } from '../store/actions/mapActions';\nimport { dijkstra, Result } from '../algorithms/dijkstra';\nimport { Cell, CellTypes } from '../models/Cell';\nimport { Algorithm } from '../models/Algorithm';\n\ninterface RawExecutorProps extends DispatchProp {\n    grid: typeof initialState.map.grid;\n    selectedAlgorithm: Algorithm;\n    isGridDirty: boolean;\n}\n\nconst VISITED_ANIMATION_TIMEOUT = .005;\nconst SHORTEST_PATH_ANIMATION_TIMEOUT = .01;\n\nexport function setClassForCell(cell: Cell, newClassName: string) {\n    const element = document.getElementById(`${cell.row}-${cell.col}`);\n    if (!element) return;\n\n    const classesToRemove: string[] = [];\n    element.classList.forEach((className) => {\n        if (className.startsWith('cell--')) {\n            classesToRemove.push(className);\n        }\n    });\n    element.classList.remove(...classesToRemove);\n\n    element.classList.add(newClassName);\n}\n\nexport function declareClassForCell(cell: Cell): string {\n    if ([CellTypes.OBSTACLE, CellTypes.START, CellTypes.END].includes(cell.type)) return `cell--${cell.type}`;\n    if (cell.isShortestPath) return 'cell--shortest-path';\n    if (cell.isVisited) return 'cell--visited';\n\n    return 'cell--free';\n}\n\nconst ALGORITHMS: {[id: string]: (grid: Cell[][]) => Result} = {\n    '1': dijkstra,\n};\n\nfunction RawExecutor({ grid, selectedAlgorithm, dispatch, isGridDirty }: RawExecutorProps) {\n    const animateShortestPath = (result: Result): void => {\n        for (let i = 0; i < result.shortestPath.length; i += 1) {\n            setTimeout(() => {\n                if ([CellTypes.START, CellTypes.END].includes(result.shortestPath[i].type)) return;\n\n                setClassForCell(result.shortestPath[i], 'cell--shortest-path');\n\n                if (i === result.shortestPath.length - 1) {\n                    dispatch(setGridAnimating(false));\n                }\n            }, 1000 * SHORTEST_PATH_ANIMATION_TIMEOUT * i)\n        }\n    }\n\n    const animateSearch = (result: Result): void => {\n        for (let i = 0; i < result.visited.length; i += 1) {\n            setTimeout(() => {\n                if (![CellTypes.START, CellTypes.END].includes(result.visited[i].type)) {\n                    setClassForCell(result.visited[i], 'cell--visited');\n                }\n\n                if (i === result.visited.length - 1) {\n                    animateShortestPath(result);\n                }\n            }, 1000 * VISITED_ANIMATION_TIMEOUT * i);\n        }\n    }\n\n    const startPathFinding = () => {\n        const algorithm = ALGORITHMS[selectedAlgorithm.id];\n        if (!algorithm) {\n            throw new Error('Selected algorithm is not defined');\n        }\n\n        dispatch(setGridAnimating(true));\n        dispatch(setGridDirty(true));\n        const searchResult = algorithm(grid);\n        animateSearch(searchResult);\n    }\n\n    return (\n        <Button onClick={startPathFinding} color=\"secondary\" variant=\"contained\" disabled={isGridDirty}>\n            Find with {selectedAlgorithm.name}\n        </Button>\n    );\n}\n\nexport const Executor = connect((state: State) => ({\n    grid: state.map.grid,\n    isGridDirty: state.map.isDirty,\n}))(RawExecutor);\n","import React, { MouseEvent } from 'react';\nimport { Cell } from '../models/Cell';\nimport { State } from '../store/state/initialState';\nimport { connect } from 'react-redux';\nimport { declareClassForCell } from './Executor';\n\ninterface NodeProps {\n    cell: Cell;\n    onMouseDown: (cell: Cell, e: MouseEvent<HTMLTableCellElement>) => void;\n    onMouseUp: (cell: Cell, e: MouseEvent<HTMLTableCellElement>) => void;\n    onMouseEnter: (cell: Cell, e: MouseEvent<HTMLTableCellElement>) => void;\n    onMouseLeave: (cell: Cell, e: MouseEvent<HTMLTableCellElement>) => void;\n    onMouseMove: (cell: Cell, e: MouseEvent<HTMLTableCellElement>) => void;\n}\n\nfunction RawNode(props: NodeProps): JSX.Element {\n    const classes = ['map__cell'];\n    classes.push(declareClassForCell(props.cell));\n\n    return <td\n        id={`${props.cell.row}-${props.cell.col}`}\n        className={classes.join(' ')}\n        style={{ width: props.cell.size, height: props.cell.size - 1 /* 1px is border */ }}\n        onMouseDown={(e) => props.onMouseDown(props.cell, e)}\n        onMouseUp={(e) => props.onMouseUp(props.cell, e)}\n        onMouseEnter={(e) => props.onMouseEnter(props.cell, e)}\n        onMouseLeave={(e) => props.onMouseLeave(props.cell, e)}\n        onMouseMove={(e) => props.onMouseMove(props.cell, e)}\n    />\n}\n\nexport const Node = connect((_: State, outerProps: { row: number; col: number; }) => {\n    return (state: State) => ({\n        cell: state.map.grid[outerProps.row][outerProps.col],\n    });\n})(RawNode);\n\n","import { Node } from './Node';\nimport React, { memo } from 'react';\nimport { Cell } from '../models/Cell';\nimport { connect, DispatchProp } from 'react-redux';\nimport { initialState, State } from '../store/state/initialState';\n\ninterface GridProps extends DispatchProp {\n    grid: Cell[][];\n    onSetCellAsObstacle: (cell: Cell) => void;\n}\n\nlet isMouseDown = false;\nfunction setMouseDown(newValue: boolean) {\n    isMouseDown = newValue;\n}\n\nexport function RawGrid({ grid, onSetCellAsObstacle }: GridProps) {\n    const handleMouseEnter = (cell: Cell) => {\n        if (!isMouseDown || cell.type !== 'free') return;\n\n        onSetCellAsObstacle(cell);\n    };\n\n    return (\n        <table className=\"map\">\n            <tbody>\n            {grid.map((row, rowId) => (\n                <tr key={rowId}>\n                    {row.map((cell) => <Node\n                        key={`${cell.row}-${cell.col}`}\n                        row={cell.row}\n                        col={cell.col}\n                        onMouseDown={() => setMouseDown(true)}\n                        onMouseUp={() => setMouseDown(false)}\n                        onMouseLeave={() => {}}\n                        onMouseEnter={() => {}}\n                        onMouseMove={handleMouseEnter}\n                    />)}\n                </tr>\n            ))}\n            </tbody>\n        </table>\n    );\n}\n\nexport const Grid = connect((state: State) => ({\n    grid: state.map?.grid || initialState.map.grid,\n}))(memo(\n    RawGrid,\n    (prevProps, nextProps) => {\n        if ((!prevProps.grid || prevProps.grid.length === 0) && nextProps?.grid.length > 0) {\n            return false;\n        }\n\n        return true;\n    },\n));\n","import React, { MouseEvent } from 'react';\nimport { Button, Menu, MenuItem } from '@material-ui/core';\nimport { Check } from '@material-ui/icons';\nimport { Algorithm } from '../models/Algorithm'\n\ninterface AlgorithmSelectProps {\n    algorithms: Algorithm[];\n    selectedAlgorithm: Algorithm;\n    onSelect: (algorithm: Algorithm) => void;\n}\n\nexport function AlgorithmSelect(props: AlgorithmSelectProps) {\n    const [anchorEl, setAnchorEl] = React.useState<HTMLElement | null>(null);\n\n    const handleOpenMenu = (event: MouseEvent<HTMLElement>): void => {\n        setAnchorEl(event.currentTarget);\n    };\n\n    const handleCloseMenu = (): void => {\n        setAnchorEl(null);\n    };\n\n    const handleSelectValue = (algorithm: Algorithm): void => {\n        props.onSelect(algorithm);\n        handleCloseMenu();\n    };\n\n    return (\n        <>\n            <Button color=\"inherit\" aria-controls=\"simple-menu\" aria-haspopup=\"true\" onClick={handleOpenMenu}>\n                Select algorithm\n            </Button>\n            <Menu\n                id=\"simple-menu\"\n                anchorEl={anchorEl}\n                keepMounted\n                open={Boolean(anchorEl)}\n                onClose={handleCloseMenu}\n            >\n                {props.algorithms.map(algorithm => (\n                    <MenuItem onClick={() => handleSelectValue(algorithm)} key={algorithm.id}>\n                        {algorithm.id === props.selectedAlgorithm.id && <Check />} {algorithm.name}\n                    </MenuItem>\n                ))}\n            </Menu>\n        </>\n    );\n}\n","import { Cell, CellTypes } from '../../models/Cell';\n\nfunction getRandomInt(min: number, max: number): number {\n    min = Math.ceil(min);\n    max = Math.floor(max);\n    return Math.floor(Math.random() * (max - min)) + min;\n}\n\nconst excludedTypes = [CellTypes.START, CellTypes.END];\n\nexport function depthFirst(grid: Cell[][]): Cell[][] {\n    // Everything is a wall first\n    const gridClone = grid.map(row => [...row.map(cell => ({\n        ...cell,\n        type: excludedTypes.includes(cell.type) ? cell.type : CellTypes.OBSTACLE,\n    }))]);\n\n\n    function examineDirections(cell: Cell) {\n        const directions = ['UP', 'DOWN', 'LEFT', 'RIGHT'].sort(() => Math.random() - 0.5);\n\n        function setCellTypes(cell1: Cell, cell2: Cell) {\n            if (cell2.type !== CellTypes.FREE) {\n                cell2.type = excludedTypes.includes(cell2.type) ? cell2.type : CellTypes.FREE;\n                cell1.type = excludedTypes.includes(cell1.type) ? cell1.type : CellTypes.FREE;\n                examineDirections(cell2);\n            }\n        }\n\n        directions.forEach((direction) => {\n            switch (direction) {\n                case 'UP': {\n                    if (cell.row - 2 <= 0) break;\n\n                    setCellTypes(\n                        gridClone[cell.row - 1][cell.col],\n                        gridClone[cell.row - 2][cell.col],\n                    );\n\n                    break;\n                }\n                case 'DOWN': {\n                    if (cell.row + 2 >= gridClone.length - 1) break;\n\n                    setCellTypes(\n                        gridClone[cell.row + 1][cell.col],\n                        gridClone[cell.row + 2][cell.col],\n                    );\n\n                    break;\n                }\n                case 'LEFT':\n                    if (cell.col - 2 <= 0) break;\n\n                    setCellTypes(\n                        gridClone[cell.row][cell.col - 1],\n                        gridClone[cell.row][cell.col - 2],\n                    );\n\n                    break;\n                case 'RIGHT':\n                    if (cell.col + 2 >= gridClone[cell.row].length - 1) break;\n\n                    setCellTypes(\n                        gridClone[cell.row][cell.col + 1],\n                        gridClone[cell.row][cell.col + 2],\n                    );\n\n                    break;\n            }\n        });\n    }\n\n    const start = gridClone[getRandomInt(0, gridClone.length - 1)][getRandomInt(0, gridClone[0].length - 1)];\n    examineDirections(start);\n    return gridClone;\n}\n","import { connect, DispatchProp } from 'react-redux';\nimport { initialState, State } from '../store/state/initialState';\nimport React from 'react';\nimport { Button } from '@material-ui/core';\nimport { depthFirst } from '../algorithms/maze/depth-first';\nimport { replaceGrid } from '../store/actions/mapActions';\n\ninterface RawMazeExecutorProps extends DispatchProp {\n    grid: typeof initialState.map.grid;\n    isGridDirty: boolean;\n}\n\nfunction RawMazeExecutor({ grid, dispatch, isGridDirty }: RawMazeExecutorProps) {\n    const execute = () => {\n        const newGrid = depthFirst(grid);\n        dispatch(replaceGrid(newGrid));\n    }\n\n    return (\n        <Button onClick={execute} color=\"inherit\" disabled={isGridDirty}>\n            Generate Maze\n        </Button>\n    );\n}\n\nexport const MazeExecutor = connect((state: State) => ({\n    grid: state.map.grid,\n    isGridDirty: state.map.isDirty,\n}))(RawMazeExecutor);\n","import React from 'react';\nimport { makeStyles } from '@material-ui/core/styles';\nimport { AppBar, Button, Toolbar, Typography } from '@material-ui/core';\nimport { Algorithm } from '../models/Algorithm';\nimport { AlgorithmSelect } from './AlgorithmSelect';\nimport { Executor } from './Executor';\nimport { MazeExecutor } from './MazeExecutor';\n\nconst useStyles = makeStyles(() => ({\n    title: {\n        flexGrow: 1,\n    },\n}));\n\ninterface HeaderBarProps {\n    algorithms: Algorithm[];\n    selectedAlgorithmIndex: number;\n    isAnimating: boolean;\n    onSelectAlgorithm: (algorithm: Algorithm) => void;\n    onClearGrid: () => void;\n}\n\nexport function HeaderBar({ algorithms, selectedAlgorithmIndex, onSelectAlgorithm, onClearGrid, isAnimating }: HeaderBarProps) {\n    const classes = useStyles();\n    const selectedAlgorithm = algorithms[selectedAlgorithmIndex];\n\n    return (\n        <AppBar position=\"static\">\n            <Toolbar>\n                <Typography variant=\"h6\" className={classes.title}>\n                    Search Visualizer\n                </Typography>\n                <MazeExecutor />\n                <AlgorithmSelect\n                    algorithms={algorithms}\n                    selectedAlgorithm={selectedAlgorithm}\n                    onSelect={onSelectAlgorithm}\n                />\n                <Executor selectedAlgorithm={selectedAlgorithm} />\n                <Button onClick={onClearGrid} color=\"inherit\" disabled={isAnimating}>Clear</Button>\n            </Toolbar>\n        </AppBar>\n    );\n}\n","import { Cell, CellTypes } from '../models/Cell';\n\nconst width = window.innerWidth * 0.8;\nconst height = window.innerHeight * 0.8;\n\nconst cellSize = 15;\n\nconst cellsPerRow = Math.floor(width / cellSize);\nconst rowsCount = Math.floor(height / cellSize);\n\nexport function generateGrid(): Cell[][] {\n    return Array(rowsCount).fill(0).map((_, rowIndex) => {\n        const isMiddleRow = rowIndex + 1 === Math.floor(rowsCount / 2);\n\n        return Array(cellsPerRow).fill(0).map((_1, colIndex) => {\n            let type = CellTypes.FREE;\n\n            if (isMiddleRow && colIndex + 1 === Math.floor(cellsPerRow * 0.25)) {\n                type = CellTypes.START;\n            } else if (isMiddleRow && colIndex + 1 === Math.floor(cellsPerRow * 0.75)) {\n                type = CellTypes.END;\n            }\n\n            return {\n                size: cellSize,\n                type,\n                isVisited: false,\n                isShortestPath: false,\n                row: rowIndex,\n                col: colIndex,\n            };\n        });\n    });\n}\n","import React, { useCallback, useEffect } from 'react';\nimport { connect, DispatchProp } from 'react-redux';\nimport './App.css';\nimport { State, initialState } from './store/state/initialState';\nimport { replaceGrid, setCellAsObstacle, setGridDirty } from './store/actions/mapActions';\nimport { Cell } from './models/Cell';\nimport { Algorithm } from './models/Algorithm';\nimport { setSelectedAlgorithm } from './store/actions/configActions';\nimport { Grid } from './components/Grid';\nimport { HeaderBar } from './components/HeaderBar';\nimport { generateGrid } from './util/generateGrid';\nimport { declareClassForCell, setClassForCell } from './components/Executor';\n\ninterface AppProps extends DispatchProp {\n    algorithms: Algorithm[];\n    selectedAlgorithmIndex: number;\n    isAnimating: boolean;\n}\n\nfunction App({ dispatch, algorithms, selectedAlgorithmIndex, isAnimating }: AppProps) {\n    const handleSelectAlgorithm = (algorithm: Algorithm) => {\n        dispatch(setSelectedAlgorithm(algorithm));\n    }\n\n    const handleSetCellAsObstacle = (cell: Cell) => {\n        dispatch(setCellAsObstacle(cell));\n    }\n\n    const handleGenerateGrid = useCallback(() => {\n        const grid = generateGrid();\n        dispatch(replaceGrid(grid));\n\n        grid.forEach(row => row.forEach((cell) => {\n            setClassForCell(cell, declareClassForCell(cell));\n        }));\n\n        dispatch(setGridDirty(false));\n    }, [dispatch]);\n\n    useEffect(() => {\n        handleGenerateGrid();\n    }, [handleGenerateGrid]);\n\n    return (\n        <div className=\"App\">\n            <HeaderBar\n                algorithms={algorithms}\n                selectedAlgorithmIndex={selectedAlgorithmIndex}\n                onSelectAlgorithm={handleSelectAlgorithm}\n                onClearGrid={handleGenerateGrid}\n                isAnimating={isAnimating}\n            />\n            <Grid onSetCellAsObstacle={handleSetCellAsObstacle} />\n        </div>\n    );\n}\n\nconst mapStateToProps = (state: State) => ({\n    algorithms: state?.config?.algorithms || initialState.config.algorithms,\n    selectedAlgorithmIndex: state?.config?.selectedAlgorithmIndex || initialState.config.selectedAlgorithmIndex,\n    isAnimating: state?.map?.isAnimating,\n});\n\nexport default connect(mapStateToProps)(App);\n","import { Action } from 'redux';\nimport { Algorithm } from '../../models/Algorithm';\n\nexport const SET_SELECTED_ALGORITHM = 'CONFIG::SET_SELECTED_ALGORITHM';\n\nexport function setSelectedAlgorithm(algorithm: Algorithm): Action<typeof SET_SELECTED_ALGORITHM> & { algorithm: Algorithm } {\n    return {\n        type: SET_SELECTED_ALGORITHM,\n        algorithm,\n    };\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React, { PropsWithChildren } from 'react';\nimport { combineReducers, compose, createStore } from 'redux';\nimport { Provider } from 'react-redux';\nimport { initialState } from './state/initialState';\nimport { map } from './reducer/map';\nimport { config } from './reducer/config';\n\nconst enhancers: Function[] = [];\n\nexport const store = createStore(\n    combineReducers({ map, config }),\n    initialState,\n    process.env.NODE_ENV === 'development'\n        ? require('redux-devtools-extension').composeWithDevTools(...enhancers)\n        : compose(...enhancers),\n);\n\nexport function Store(props: PropsWithChildren<{}>) {\n    return (\n        <Provider store={store}>\n            {props.children}\n        </Provider>\n    );\n}\n","import { AnyAction } from 'redux';\nimport { set } from 'object-path-immutable';\nimport { CellTypes } from '../../models/Cell';\nimport { initialState } from '../state/initialState';\nimport {\n    SET_CELL_AS_OBSTACLE,\n    SET_CELL_AS_SHORTEST_PATH,\n    REPLACE_GRID,\n    SET_DIRTY,\n    SET_ANIMATING,\n} from '../actions/mapActions';\n\ntype MapState = typeof initialState.map;\n\nexport function map(state = initialState.map, action: AnyAction): MapState {\n    switch (action.type) {\n        case SET_CELL_AS_OBSTACLE:\n            return set(state, `grid.${action.cell.row}.${action.cell.col}.type`, CellTypes.OBSTACLE);\n        case REPLACE_GRID:\n            return {\n                ...state,\n                grid: action.grid,\n            };\n        case SET_DIRTY:\n            return {\n                ...state,\n                isDirty: action.isDirty,\n            };\n        case SET_ANIMATING:\n            return {\n                ...state,\n                isAnimating: action.isAnimating,\n            };\n        case SET_CELL_AS_SHORTEST_PATH:\n            return set(state, `grid.${action.cell.row}.${action.cell.col}.isShortestPath`, true);\n        default:\n            return state;\n    }\n}\n","import { AnyAction } from 'redux';\nimport { SET_SELECTED_ALGORITHM } from '../actions/configActions';\nimport { initialState } from '../state/initialState';\n\ntype ConfigState = typeof initialState.config;\n\nexport function config(state = initialState.config, action: AnyAction): ConfigState {\n    switch (action.type) {\n        case SET_SELECTED_ALGORITHM:\n            return {\n                ...state,\n                selectedAlgorithmIndex: state.algorithms.findIndex(algorithm => algorithm.id === action.algorithm.id),\n            };\n        default:\n            return state;\n    }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport { Store } from './store';\n\nReactDOM.render(\n    <React.StrictMode>\n        <Store>\n            <App />\n        </Store>\n    </React.StrictMode>,\n    document.getElementById('root'),\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}